from User_Auth.database import db
from datetime import datetime 
from sqlalchemy import text
import json
# table for holding all recipes generated by our system on behalf of another user
class SavedRecipe(db.Model):
    __tablename__ = 'generated_recipes'

    meal_id = db.Column(db.String(80), primary_key=True, nullable=False)
    
    # Foreign key to existing users table
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)

    # Core recipe fields
    recipe_name = db.Column(db.String(255), nullable=False)
    meal_type = db.Column(db.String(40), nullable=False)

    instructions = db.Column(db.Text, nullable=True)
    ingredients = db.Column(db.Text, nullable=True)
    #health_info = db.Column(db.Text, nullable=True)
    carbs=db.Column(db.Integer,nullable=True)
    fats=db.Column(db.Integer,nullable=True)
    protein=db.Column(db.Integer,nullable=True)
    created_on = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    ingredient_amounts=db.Column(db.Text,nullable=True)
    ingredient_units=db.Column(db.Text,nullable=True)
    calories=db.Column(db.Integer,nullable=True)



    def __repr__(self):

        return f" Recipe: {self.recipe_name} Saved for user (User {self.user_id})>"


#table for storing the meals users have saved to a given collection
class MealCollections(db.Model):
    __tablename__ = 'collection_meals'

    meal_id = db.Column(db.String(80),db.ForeignKey('generated_recipes.meal_id'), primary_key=True, nullable=False)
    
    # Foreign key to existing users table
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)

    collection_name=db.Column(db.String(200),nullable=False)



# stores all collections created by users
class CollectionInfo(db.Model):
    __tablename__="collections"
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), primary_key=True, nullable=False)
    
    collection_name=db.Column(db.String(200),nullable=False)
    collection_image=db.Column(db.Text,nullable=True)

def getCollectionMeals(userID):
    if userID is None:
        return []
    return MealCollections.query.filter_by(user_id=userID).all()
# returns all collections for a given user
def getCollections(userID):
    if userID is None:
        return []
    rows = CollectionInfo.query.filter_by(user_id=userID).all()
    return [row.collection_name for row in rows]


# generated a disct with the following info,
# user meal collection names, number of  meals in collections
def getUserMeals(userID):
    if userID is None:
        return []
    rows = db.session.execute(
        text(
            """
            select collection_name, count(*) as item_count
            from collection_meals
            where user_id = :user_id
            group by collection_name
            order by collection_name
            """
        ),
        {"user_id": userID},
    ).mappings().all()

    mealCollections = []
    for idx, row in enumerate(rows):
        mealCollections.append({
            "id": idx,
            "name": row.get("collection_name"),
            "item_count": row.get("item_count", 0),
        })
    return mealCollections


def getAllMeals(userID):
    if userID is None:
        return []
    return (
        SavedRecipe.query
        .filter_by(user_id=userID)
        .order_by(SavedRecipe.created_on.desc())
        .all()
    )

# adds new meal to a collection if it hasnt been already
def addMealToCollection(userID,collectionName,mealID):
    meal2Add=MealCollections(user_id=userID,collection_name=collectionName,meal_id=mealID)
    alreadyAdded = MealCollections.query.filter_by(
    user_id=userID,
    meal_id=mealID,
    collection_name=collectionName
    ).first()
    if alreadyAdded:
        return False
    
    db.session.add(meal2Add)
    db.session.commit()
    return True


# adds a new collection to the databsse if it doesent exist
def createNewCollection(userID,collectionName):
    alreadyCreated = CollectionInfo.query.filter_by(
    collection_name=collectionName,
    user_id=userID
    ).first()
    if alreadyCreated:
        return False

    newCollectionm = CollectionInfo(user_id=userID,collection_name=collectionName)
    db.session.add(newCollectionm)
    db.session.commit()
    return True

# used to generate unique recipe Ids to help with saviing meals in the front end
def generatemealIDs(userID,nRecipes):
    # SavedRecipe.__table__.drop(db)
    # SavedRecipe.__table__.create(db)
    # db.create_all()
    recipe_count = SavedRecipe.query.filter_by(user_id=userID).count()
    ids=[]
    
    for x in range(recipe_count+1,((recipe_count+1)+nRecipes)):
        ids.append(f"{userID}_{x}")
    return ids


# function to add newly generated meals to database
def _serialize_field(value):
    if value in (None, ""):
        return None
    if isinstance(value, str):
        return value
    try:
        return json.dumps(value)
    except (TypeError, ValueError):
        return str(value)


def _safe_int(value):
    try:
        if value in (None, ""):
            return None
        return int(value)
    except (TypeError, ValueError):
        return None


def saveNewMeals(userID, newMeals, units=None, quants=None):
    meals_payload = (newMeals or {}).get("meals") or []
    units = units or []
    quants = quants or []
    saved_any = False

    for idx, meal in enumerate(meals_payload):
        meal_id = meal.get("id")
        if not meal_id:
            continue

        unit_payload = units[idx] if idx < len(units) else []
        quant_payload = quants[idx] if idx < len(quants) else []

        newMeal = SavedRecipe(
            user_id=userID,
            meal_id=meal_id,
            recipe_name=meal.get("name"),
            meal_type=meal.get("mealType"),
            instructions=_serialize_field(meal.get("instructions")),
            ingredients=_serialize_field(meal.get("ingredients")),
            carbs=_safe_int(meal.get("carbs")),
            fats=_safe_int(meal.get("fats")),
            protein=_safe_int(meal.get("protein")),
            ingredient_amounts=_serialize_field(quant_payload),
            ingredient_units=_serialize_field(unit_payload),
            calories=_safe_int(meal.get("calories")),
        )

        db.session.merge(newMeal)
        saved_any = True

    if saved_any:
        db.session.commit()
    return saved_any



