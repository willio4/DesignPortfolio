from User_Auth.database import db
from datetime import datetime 
from sqlalchemy import select, text
import pandas as pd
# table for holding all recipes generated by our system on behalf of another user
class SavedRecipe(db.Model):
    __tablename__ = 'generated_recipes'

    meal_id = db.Column(db.String(80), primary_key=True, nullable=False)
    
    # Foreign key to existing users table
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)

    # Core recipe fields
    recipe_name = db.Column(db.String(255), nullable=False)
    meal_type = db.Column(db.String(40), nullable=False)

    instructions = db.Column(db.Text, nullable=True)
    ingredients = db.Column(db.Text, nullable=True)
    #health_info = db.Column(db.Text, nullable=True)
    carbs=db.Column(db.Integer,nullable=True)
    fats=db.Column(db.Integer,nullable=True)
    protein=db.Column(db.Integer,nullable=True)
    created_on = db.Column(db.DateTime, default=datetime.utcnow, nullable=False)
    ingredient_amounts=db.Column(db.Text,nullable=True)
    ingredient_units=db.Column(db.Text,nullable=True)
    calories=db.Column(db.Integer,nullable=True)



    def __repr__(self):

        return f" Recipe: {self.recipe_name} Saved for user (User {self.user_id})>"


#table for storing the meals users have saved to a given collection
class MealCollections(db.Model):
    __tablename__ = 'collection_meals'

    meal_id = db.Column(db.String(80),db.ForeignKey('generated_recipes.meal_id'), primary_key=True, nullable=False)
    
    # Foreign key to existing users table
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)

    collection_name=db.Column(db.String(200),nullable=False)



# stores all collections created by users
class CollectionInfo(db.Model):
    __tablename__="collections"
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), primary_key=True, nullable=False)
    
    collection_name=db.Column(db.String(200),nullable=False)
    collection_image=db.Column(db.Text,nullable=True)

def getCollectionMeals(userID):
    # Legacy raw SQL (pre-Postgres fix):
    # colQ = f'''select * from collection_meals where user_id="{userID}"'''
    # df = pd.read_sql(colQ, db.engine)
    # I switched this to a parameterized query so Supabase stops choking on quotes.
    col_query = text("""
        select *
        from collection_meals
        where user_id = :user_id
    """)
    df = pd.read_sql(col_query, db.engine, params={"user_id": userID})
    return df
# returns all collections for a given user
def getCollections(userID):
    # Legacy raw SQL (pre-Postgres fix):
    # queryCollections = f'''
    # 
    # select * from collections
    # where user_id="{userID}"
    # '''
    # Keeping this parameterized keeps us out of SQL injection trouble on the hosted DB.
    queryCollections = text("""
        select *
        from collections
        where user_id = :user_id
    """)
    collections = []
    userMeals = pd.read_sql(queryCollections, db.engine, params={"user_id": userID})
    if len(userMeals) == 0:
        return []
    else:
        for collection in userMeals["collection_name"].unique():
            collections.append(collection)
    return collections


# generated a disct with the following info,
# user meal collection names, number of  meals in collections
def getUserMeals(userID):
    # query=select(MealCollections).where(MealCollections.user_id==userID)
    # query for getting user collections
    # Legacy raw SQL (pre-Postgres fix):
    # queryCollections = f'''
    # 
    # select * from collections
    # where user_id="{userID}"
    # '''
    queryCollections = text("""
        select *
        from collections
        where user_id = :user_id
    """)
    userMeals = pd.read_sql(queryCollections, db.engine, params={"user_id": userID})
    # loop all collections return dict meant for front end parsing
    mealCollections=[]
    localMealID=0
    if len(userMeals)==0:
        return mealCollections
    else:
        # for eeach collection get number of meals in it
        for collection in userMeals["collection_name"].unique():
            # Legacy raw SQL (pre-Postgres fix):
            # queryMeals = f'''
            # select * from collection_meals 
            # where user_id= "{userID} and collection_name={collection}"
            # '''
            # Parameterizing collection lookups here fixed the Supabase “syntax error at '"'” spam.
            queryMeals = text("""
                select *
                from collection_meals
                where user_id = :user_id
                    and collection_name = :collection_name
            """)
            collectionMeals = pd.read_sql(
                queryMeals,
                db.engine,
                params={"user_id": userID, "collection_name": collection}
            )

            mealCollections.append({"id":localMealID,"name":collection,"item_count":len(collectionMeals)})
            localMealID+=1 
    return mealCollections


def getAllMeals(userID):
    # Legacy raw SQL (pre-Postgres fix):
    # q2 = f'''select * from generated_meals where user_id="{userID}'''
    # Same story here—param binding or bust on the managed Postgres instance.
    q2 = text("""
        select *
        from generated_recipes
        where user_id = :user_id
    """)
    allMeals = pd.read_sql(q2, db.engine, params={"user_id": userID})
    return allMeals

# adds new meal to a collection if it hasnt been already
def addMealToCollection(userID,collectionName,mealID):
    meal2Add=MealCollections(user_id=userID,collection_name=collectionName,meal_id=mealID)
    alreadyAdded = MealCollections.query.filter_by(
    user_id=userID,
    meal_id=mealID,
    collection_name=collectionName
    ).first()
    if alreadyAdded:
        return False
    
    db.session.add(meal2Add)
    db.session.commit()
    db.session.close()
    return True


# adds a new collection to the databsse if it doesent exist
def createNewCollection(userID,collectionName):
    alreadyCreated = CollectionInfo.query.filter_by(
    collection_name=collectionName,
    user_id=userID
    ).first()
    if alreadyCreated:
        return False

    newCollectionm = CollectionInfo(user_id=userID,collection_name=collectionName)
    db.session.add(newCollectionm)
    db.session.commit()
    db.session.close()
    return True

# used to generate unique recipe Ids to help with saviing meals in the front end
def generatemealIDs(userID,nRecipes):
    # SavedRecipe.__table__.drop(db)
    # SavedRecipe.__table__.create(db)
    # db.create_all()
    recipe_count = SavedRecipe.query.filter_by(user_id=userID).count()
    ids=[]
    
    for x in range(recipe_count+1,((recipe_count+1)+nRecipes)):
        ids.append(f"{userID}_{x}")
    return ids


# function to add newly generated meals to database
def saveNewMeals(userID,newMeals,units,quants):
    # print("MEALS",newMeals)
    # upload each meal to the database
    for meal,u,q in zip(newMeals["meals"],units,quants):


        # Tess: Commented this out for now to fix the nested f-string error ↓
        # uncommented the commented out portion after fixing nested f string error. 
        # had to convert some double quotes to single quotes
        # create new meal object

        newMeal=SavedRecipe(user_id=userID,meal_id=meal["id"],recipe_name=meal["name"],meal_type=meal["mealType"],
        instructions=f"{meal['instructions']}",ingredients=f"{meal['ingredients']}",carbs=meal["carbs"],
        fats=meal["fats"],protein=meal["protein"],ingredient_amounts=f"{q}",ingredient_units=f"{u}",calories=meal['calories'])

                # create new meal object (use .get and avoid nested f-strings)
        # newMeal = SavedRecipe(
        #     user_id=userID,
        #     meal_id=meal.get("id"),
        #     recipe_name=meal.get("name"),
        #     meal_type=meal.get("mealType"),
        #     instructions=str(meal.get("instructions")) if meal.get("instructions") is not None else None,
        #     ingredients=str(meal.get("ingredients")) if meal.get("ingredients") is not None else None,
        #     carbs=meal.get("carbs"),
        #     fats=meal.get("fats"),
        #     protein=meal.get("protein"),
        # )

        db.session.add(newMeal)
        db.session.commit()
        db.session.close()



